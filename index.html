<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Farcade Boy</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #111;
        overflow: hidden;
        font-family: "Segoe UI", sans-serif;
      }

      #game-container {
        max-width: 400px;
        width: 100%;
        position: relative;
      }

      canvas {
        display: block;
        background: #fff;
        width: 100%;
        height: auto;
      }

      /* üéÆ Start Screen */
      #start-screen {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("https://github.com/Luci13131313/Farcade-Run/blob/main/FarcadeBoy.png?raw=true");
        background-size: cover;
        background-position: center;
        z-index: 10;
        backdrop-filter: blur(3px);
        color: #111;
        font-weight: 600;
        pointer-events: auto;
      }

      #start-title {
        position: absolute;
        bottom: 50px;
        width: 100%;
        text-align: center;
        font-size: 26px;
        color: #000;
        text-shadow: 1px 1px 4px #fff;
      }

      #start-desc {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
        font-size: 14px;
        color: #000;
        text-shadow: 1px 1px 3px #fff;
      }

      #start-run-label {
        position: absolute;
        pointer-events: auto;
        top: 255px;
        width: 100%;
        text-align: center;
        font-size: 20px;
        color: #111;
        text-shadow: 1px 1px 3px #fff;
      }

      #hint-label {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.7);
        padding: 4px 10px;
        border-radius: 10px;
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        z-index: 20;
        pointer-events: all;
      }

      #guide-screen {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.4); /* translucent overlay */
        backdrop-filter: blur(4px); /* softens image behind */
        z-index: 12;
        padding: 0 20px;
        font-size: 14px;
        overflow: hidden;
        text-align: center;
        box-sizing: border-box;
      }

      #guide-screen h2 {
        font-size: 24px;
        margin-bottom: 8px;
        color: #111;
      }

      #guide-screen p {
        font-size: 13px;
        line-height: 1.4;
        margin-bottom: 20px;
        max-width: 300px;
      }

      #guide-screen button {
        margin-top: 8px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
  </head>
  <body>
    <div id="game-container">
      <canvas id="game"></canvas>
      <div id="start-screen">
        <div id="hint-label">Hints</div>
        <div id="start-run-label" style="pointer-events: none; opacity: 0.4">Tap/Click to Start</div>
        <div id="start-desc">Run as far as you can, avoid obstacles and holes.</div>
        <div id="start-title">Farcade Boy: The Run</div>
      </div>

      <div id="guide-screen" style="display: none">
        <div
          class="poster-box"
          style="
            background: rgba(255, 255, 255, 0.85);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            max-width: 340px;
          "
        >
          <h2 style="font-size: 26px; margin-bottom: 12px; color: #222; text-shadow: 1px 1px 2px #fff">
            üéÆ How to Play
          </h2>
          <p style="font-size: 14px; line-height: 1.6; color: #333">
            üïπ <b>Tap / Click / Space</b> = Jump<br />
            üîÅ <b>Double Tap</b> = Backflip & Double Jump<br /><br />
            üåü <b>Bonuses:</b><br />
            ‚≠ê <b>Star</b> = Speed Reset<br />
            ‚ö´ <b>Dark Star</b> = x2 Speed + Invincible<br />
            üõ° <b>Shield</b> = Temporary Protection<br />
            üéÆ <b>Farcade Logo</b> = 1-Up (Extra Life)<br /><br />
            ‚ö†Ô∏è Each new bonus <b>replaces</b> the last!
          </p>
          <button
            id="close-guide"
            style="
              margin-top: 10px;
              font-size: 14px;
              padding: 6px 12px;
              border: none;
              border-radius: 6px;
              background: #222;
              color: #fff;
              cursor: pointer;
              box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
            "
          >
            Back
          </button>
        </div>
      </div>
    </div>

    <script>
      const soundVolumes = {
        bgm: 0.3,
        hit: 0.2,
        gameover: 0.4,
        coin: 0.5,
        star: 0.2,
        crowd: 0.4,
        jump: 0.1,
      };

      const sounds = {
        bgm: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/FRbgs.mp3"),
        hit: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/hit.mp3"),
        gameover: new Audio(
          "https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/gameover.mp3",
        ),
        coin: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/coin.mp3"),
        star: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/star.mp3"),
        crowd: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/crowd.mp3"),
        darkstar: new Audio(
          "https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/darkstar.mp3",
        ),
        shield: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/shield.mp3"),
        hole: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/hole.mp3"),
        jump: new Audio("https://raw.githubusercontent.com/Luci13131313/Farcade-Run/main/assets/sounds/jump.mp3"),
      };

      sounds.jump.volume = 0.3;
      sounds.darkstar.volume = 0.4;
      sounds.star.volume = 0.2;
      sounds.hit.volume = 0.3;
      sounds.bgm.loop = true;
      sounds.bgm.volume = 0.3;
      sounds.shield.volume = 0.3;
      let isMuted = false;

      function playSound(name) {
        if (isMuted || !sounds[name]) return;
        const sfx = sounds[name].cloneNode();
        sfx.volume = soundVolumes[name] ?? 0.4;
        sfx.play();
      }

      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      canvas.width = 640;
      canvas.height = 640;

      const logo = new Image();
      logo.src = "https://github.com/Luci13131313/Farcade-Run/blob/main/logo.png?raw=true";

      const shieldImg = new Image();
      shieldImg.src = "https://github.com/Luci13131313/Farcade-Run/blob/main/shield.png?raw=true";

      const tribuneImages = [
        "https://github.com/Luci13131313/Farcade-Run/blob/main/ist.png?raw=true",
        "https://github.com/Luci13131313/Farcade-Run/blob/main/07792108-2895-41f6-9a6b-e27a4b1452cc.png?raw=true",
        "https://github.com/Luci13131313/Farcade-Run/blob/main/2ad09f81-a8db-4306-8925-b5b9200fbe8d.png?raw=true",
        "https://github.com/Luci13131313/Farcade-Run/blob/main/2b4052ea-4d69-4d3c-807f-49cddbc0d105.png?raw=true",
        "https://github.com/Luci13131313/Farcade-Run/blob/main/2c51b7b4-fec6-4152-9163-a63f4ff5507a.png?raw=true",
      ];

      const tribunes = tribuneImages.map((src) => {
        const img = new Image();
        img.src = src;
        img.onload = checkStart;
        return img;
      });

      const player = {
        x: 500,
        y: 480,
        torsoLength: 20,
        legLength: 20,
        armLength: 20,
        footSize: 6,
        velocityY: 0,
        isJumping: false,
        fallingInHole: false,
      };

      const colors = ["blue", "red", "green", "purple", "yellow", "pink"];

      const neonColors = [
        "#FF6EC7", // Neon Pink
        "#39FF14", // Neon Green
        "#1F51FF", // Neon Blue
        "#00FFFF", // Electric Cyan
        "#FF3131", // Bright Red
        "#D900FF", // Neon Purple
        "#FFFF33", // Bright Yellow
      ];

      const maxJump = 2;
      const jumpVelocity = -14;
      let jumpCount = 0;
      let lastJumpCount = 0;
      let isBackflipping = false;
      let backflipAngle = 0;
      let gravity = 0.4;

      // üí• Durumlar & Can
      let lives = 1;
      let isGameOver = false;
      let damageCooldown = 0;
      let rebirthTimer = 0;
      let ghostOpacity = 1;
      let tribuneOpacity = 0;

      // üõ°Ô∏è Bonus Mekanikleri
      let bonusTimer = 0;
      let speedBoostTimer = 0;
      let darkBoostTimer = 0;
      let shieldTimer = 0;
      let hasShield = false;
      let darkStarInvincible = false;
      let darkBoostedSpeed = 6;

      // üîä Ses & Mesajlar
      let bonusMessage = "";
      let bonusMessageTimer = 0;
      let statusMessage = "";
      let statusTimer = 0;

      // üïπÔ∏è Oyun Akƒ±≈üƒ±
      let distance = 0.1;
      let baseSpeed = 4;
      let gameSpeed = baseSpeed;
      let difficultyLevel = 1;
      let obstacleCount = 0;
      let obstacleTimer = 10;
      let obstacleDifficultyTimer = 0;
      let comboCooldownTimer = 0;
      let recentlySpawnedCombo = false;

      // üï≥Ô∏è Engeller & D√º≈ü√º≈üler
      const obstacles = [];
      let holeFallData = null;
      let lastHoleObstacleCount = 0;

      // üåÑ Zaman & G√ºn D√∂ng√ºs√º
      let timeOfDay = 0;
      let isDay = true;

      // üë• Tribune Mekaniƒüi
      let showTribune = false;
      let currentTribune = 1;
      let nextTribuneDistance = 5;
      let tribuneTimer = 0;
      let tribuneX = 0;
      let tribune2X = 0;

      // üõ£Ô∏è Zemin ve Yol
      let roadType = 1;
      let nextRoadSwitch = 250;

      // üå•Ô∏è Arka Plan & Efektler
      const clouds = [
        { x: 50, y: 100 },
        { x: 200, y: 60 },
        { x: 320, y: 130 },
      ];

      const birds = [
        { x: 300, y: 80 },
        { x: 100, y: 150 },
      ];

      let angle = 0;

      // üéûÔ∏è Oyun D√∂ng√ºs√º
      let lastTime = performance.now();
      let loopId = null;

      let assetsLoaded = 0;
      let shieldLoaded = false;

      expectedAssets = 2 + tribuneImages.length; // logo + shield + 5 tribune

      logo.onload = checkStart;
      shieldImg.onload = () => {
        shieldLoaded = true;
        checkStart();
      };

      function checkStart() {
        assetsLoaded++;
        console.log("Loaded", assetsLoaded, "/", expectedAssets);
        if (assetsLoaded >= expectedAssets) {
          document.getElementById("start-run-label").style.pointerEvents = "auto";
          document.getElementById("start-run-label").style.opacity = "1";
        }
      }

      function drawHead() {
        ctx.save();
        ctx.globalAlpha = ghostOpacity;

        const headSize = 80;
        const offsetY = -15;
        const x = player.x;
        const y = -player.torsoLength - headSize / 2 + 10; // kafa biraz a≈üaƒüƒ±

        // ‚ú® Disco efekti varsa glow √ßiz
        if (speedBoostTimer > 0 || darkBoostTimer > 0) {
          const glowColors =
            darkBoostTimer > 0
              ? ["#111", "#333", "#555", "#999"]
              : ["#ff99cc", "#99ccff", "#ccff66", "#ffcc66", "#66ccff"];
          const glowColor = glowColors[Math.floor(Date.now() / 150) % glowColors.length];

          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 45;
        }

        ctx.translate(x, y);

        if (isBackflipping) {
          ctx.rotate((backflipAngle * Math.PI) / 180);
        }

        ctx.drawImage(logo, -headSize / 2, -headSize / 2, headSize, headSize);

        ctx.restore();
      }

      function drawTorso() {
        ctx.save();
        ctx.globalAlpha = ghostOpacity;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 7;

        if (shieldTimer > 0) {
          ctx.shadowColor = "#a66cff"; // Farcade mor tonu
          ctx.shadowBlur = 45;
        } else if (speedBoostTimer > 0 || darkBoostTimer > 0) {
          ctx.shadowColor = getDiscoGlowColor();
          ctx.shadowBlur = 40;
        }

        const torsoTopY = player.y - player.torsoLength;
        ctx.beginPath();
        ctx.moveTo(player.x, torsoTopY);
        ctx.lineTo(player.x, player.y);
        ctx.stroke();
        ctx.restore();
        return torsoTopY;
      }

      function drawArms(torsoTopY) {
        ctx.save();
        ctx.globalAlpha = ghostOpacity;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 6;
        const swing = Math.sin(angle) * 10;
        const lift = Math.cos(angle) * 5;

        if (shieldTimer > 0) {
          ctx.shadowColor = "#a66cff"; // Farcade mor tonu
          ctx.shadowBlur = 45;
        } else if (speedBoostTimer > 0 || darkBoostTimer > 0) {
          ctx.shadowColor = getDiscoGlowColor();
          ctx.shadowBlur = 40;
        }

        ctx.beginPath();
        ctx.moveTo(player.x, torsoTopY + 5);
        ctx.lineTo(player.x + swing, torsoTopY + player.armLength + lift);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(player.x, torsoTopY + 5);
        ctx.lineTo(player.x - swing, torsoTopY + player.armLength - lift);
        ctx.stroke();
        ctx.restore();
      }

      function drawLegs() {
        ctx.save();
        ctx.globalAlpha = ghostOpacity;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 5;

        if (shieldTimer > 0) {
          ctx.shadowColor = "#a66cff"; // Farcade mor tonu
          ctx.shadowBlur = 45;
        } else if (speedBoostTimer > 0 || darkBoostTimer > 0) {
          ctx.shadowColor = getDiscoGlowColor();
          ctx.shadowBlur = 40;
        }

        const swing = Math.sin(angle) * 10;

        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(player.x - swing, player.y + player.legLength);
        ctx.stroke();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(player.x - swing, player.y + player.legLength, player.footSize, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(player.x + swing, player.y + player.legLength);
        ctx.stroke();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(player.x + swing, player.y + player.legLength, player.footSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawCharacter() {
        ctx.save();
        ctx.globalAlpha = ghostOpacity;

        const centerX = player.x;
        const centerY = player.y - player.torsoLength / 2;

        ctx.translate(centerX, centerY);

        if (isBackflipping) {
          ctx.rotate((backflipAngle * Math.PI) / 180);
        }

        // Glow efekti (disco aktifse)
        if (shieldTimer > 0) {
          ctx.shadowColor = "#b26bff"; // Mor ton (play again ekranƒ±na uyumlu)
          ctx.shadowBlur = 45;
        } else if (speedBoostTimer > 0 || darkBoostTimer > 0) {
          ctx.shadowColor = getDiscoGlowColor();
          ctx.shadowBlur = 40;
        }

        // Karakter par√ßalarƒ±nƒ± d√∂nd√ºr√ºlm√º≈ü koordinata g√∂re √ßiz
        drawHeadInternal();
        const torsoTopY = drawTorsoInternal();
        drawArmsInternal(torsoTopY);
        drawLegsInternal();

        ctx.restore();
      }

      function drawHeadInternal() {
        const headSize = 80;
        const torsoTopY = -player.torsoLength; // g√∂vdenin √ºst noktasƒ±
        const y = torsoTopY - headSize + 15;

        ctx.drawImage(logo, -headSize / 2, y, headSize, headSize);
      }

      function drawTorsoInternal() {
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 7;

        const torsoTopY = -player.torsoLength;
        const torsoBottomY = 0;

        ctx.beginPath();
        ctx.moveTo(0, torsoTopY);
        ctx.lineTo(0, torsoBottomY);
        ctx.stroke();

        return torsoTopY; // Kol referansƒ± i√ßin
      }

      function drawArmsInternal(torsoTopY) {
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 5;

        const swing = Math.sin(angle) * 10;
        const lift = Math.cos(angle) * 5;

        ctx.beginPath();
        ctx.moveTo(0, torsoTopY + 5);
        ctx.lineTo(swing, torsoTopY + player.armLength + lift);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, torsoTopY + 5);
        ctx.lineTo(-swing, torsoTopY + player.armLength - lift);
        ctx.stroke();
      }

      function drawLegsInternal() {
        if (shieldTimer > 0) {
          ctx.shadowColor = "#a66cff"; // Farcade mor tonu
          ctx.shadowBlur = 45;
        } else if (speedBoostTimer > 0 || darkBoostTimer > 0) {
          ctx.shadowColor = getDiscoGlowColor();
          ctx.shadowBlur = 40;
        } else {
          ctx.shadowColor = "transparent";
        }

        ctx.fillStyle = "#000";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 5;

        const swing = Math.sin(angle) * 10;
        const legY = player.legLength;

        // Left leg
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-swing, legY);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(-swing, legY, player.footSize, 0, Math.PI * 2);
        ctx.fill();

        // Right leg
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(swing, legY);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(swing, legY, player.footSize, 0, Math.PI * 2);
        ctx.fill();
      }

      function updateRoadTypeByTime() {
        if (timeOfDay < 0.4) {
          roadType = 3; // sabah: √ßimenli
        } else if (timeOfDay < 0.8) {
          roadType = 1; // ak≈üam: toprak
        } else {
          roadType = 2; // gece: ta≈ülƒ±
        }
      }

      function drawTribunes(delta) {
        if (!delta || typeof delta !== "number" || !showTribune) return;

        const img = tribunes[(currentTribune - 1) % tribunes.length];
        if (!img.complete) return;

        const h = 280;
        const y = 525 - h;
        const tribuneX = 0;

        // Oyuncu ge√ßerken fade etkisi (yakla≈üma ve uzakla≈üma)
        const playerScreenX = canvas.width * 0.5;
        const tribuneCenter = canvas.width * 0.5;
        const relativeDistance = Math.abs(playerScreenX - tribuneCenter);
        const maxFadeDist = canvas.width * 0.5;
        tribuneOpacity = 1 - relativeDistance / maxFadeDist;
        tribuneOpacity = Math.max(0, Math.min(1, tribuneOpacity));

        ctx.save();
        ctx.globalAlpha = tribuneOpacity;
        ctx.drawImage(img, tribuneX, y, canvas.width, h);
        ctx.restore();

        if (distance > nextTribuneDistance + 8) {
          showTribune = false;
          nextTribuneDistance = distance + (currentTribune === 1 ? 100 : 50);
          sounds.crowd.pause();
          sounds.crowd.currentTime = 0;
        }

        updateRoadTypeByTime();
      }

      function rand(x, y) {
        return (Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
      }

      function drawRoad() {
        const roadSegments = [];
        let lastX = 0;

        obstacles.forEach((obs) => {
          if (obs.type === "hole") {
            if (obs.x > lastX) {
              roadSegments.push({ x: lastX, width: obs.x - lastX });
            }
            lastX = obs.x + obs.size;
          }
        });

        if (lastX < canvas.width) {
          roadSegments.push({ x: lastX, width: canvas.width - lastX });
        }

        roadSegments.forEach((seg) => {
          const topY = 500;
          const height = canvas.height - 500;
          const topH = 30;
          const bottomH = height - topH;

          const worldOffset = Math.floor(distance * 100);

          if (roadType === 1) {
            ctx.fillStyle = "#e2cfa4";
            ctx.fillRect(seg.x, topY, seg.width, topH);
            for (let i = 0; i < seg.width; i += 5) {
              const rx = rand(worldOffset + seg.x + i, topY);
              ctx.fillStyle = rx < 0.5 ? "#cbb38c" : "#a38d6f";
              ctx.beginPath();
              ctx.arc(seg.x + i, topY + rx * topH, 0.6, 0, Math.PI * 2);
              ctx.fill();
            }
            const grad = ctx.createLinearGradient(seg.x, topY + topH, seg.x, topY + height);
            grad.addColorStop(0, "#b59871");
            grad.addColorStop(1, "#826448");
            ctx.fillStyle = grad;
            ctx.fillRect(seg.x, topY + topH, seg.width, bottomH);
          } else if (roadType === 2) {
            // Ta≈ü Yol - sabit desenli, oyun akƒ±≈üƒ±yla senkron
            ctx.fillStyle = "#c87d5a";
            ctx.fillRect(seg.x, topY, seg.width, topH);

            const stoneW = 16;
            const stoneH = 10;
            const mortar = 2;

            for (let x = seg.x - (seg.x % stoneW); x < seg.x + seg.width; x += stoneW) {
              for (let y = topY; y < topY + topH; y += stoneH) {
                const wx = Math.floor((worldOffset + x) / stoneW) * stoneW;
                const wy = Math.floor(y / stoneH) * stoneH;
                const offset = (Math.floor((wx + wy) / 20) % 2) * (stoneW / 2);
                const w = stoneW - mortar + rand(wx, wy) * 2;
                const h = stoneH - mortar + rand(wx + 40, wy) * 2;

                ctx.beginPath();
                ctx.fillStyle = `hsl(15, 40%, ${45 + rand(wx, wy) * 25}%)`; // kƒ±rmƒ±zƒ±msƒ± kahve ton
                ctx.roundRect(wx + offset, wy, w, h, 2);
                ctx.fill();
                ctx.strokeStyle = "#6e5b4b";
                ctx.lineWidth = 0.4;
                ctx.stroke();
              }
            }

            const grad = ctx.createLinearGradient(seg.x, topY + topH, seg.x, topY + height);
            grad.addColorStop(0, "#b6664d"); // a√ßƒ±k tuƒüla rengi
            grad.addColorStop(1, "#8e3e2b"); // koyu kiremit
            ctx.fillStyle = grad;
            ctx.fillRect(seg.x, topY + topH, seg.width, bottomH);
          } else if (roadType === 3) {
            const grassTop = ctx.createLinearGradient(seg.x, topY, seg.x, topY + topH);
            grassTop.addColorStop(0, "#b0d472");
            grassTop.addColorStop(1, "#6ea83d");
            ctx.fillStyle = grassTop;
            ctx.fillRect(seg.x, topY, seg.width, topH);

            for (let i = 0; i < seg.width; i += 3) {
              const x = seg.x + i;
              const bladeHeight = 6 + rand(worldOffset + x, topY) * 4;
              ctx.strokeStyle = rand(worldOffset + x, topY) < 0.5 ? "#6ea83d" : "#4f8020";
              ctx.beginPath();
              ctx.moveTo(x, topY + topH);
              ctx.lineTo(x, topY + topH - bladeHeight);
              ctx.stroke();
            }

            const grad = ctx.createLinearGradient(seg.x, topY + topH, seg.x, topY + height);
            grad.addColorStop(0, "#619c3b");
            grad.addColorStop(1, "#3b6823");
            ctx.fillStyle = grad;
            ctx.fillRect(seg.x, topY + topH, seg.width, bottomH);
          }
        });
      }

      function drawObstacles() {
        if (obstacleCount === 0 && distance >= 0.02) {
          obstacles.length = 0;
          obstacles.push({
            type: "hole",
            x: -40, // ekrana hemen girsin
            y: 0,
            size: 60,
            color: "#000",
          });
          obstacleCount++; // bu √∂nemli, yoksa tekrar ekler
          lastHoleObstacleCount = 0;
          obstacleTimer = 60; // k√º√ß√ºk bir bekleme
          return; // bu frame'de sadece bu olsun
        }

        obstacles.forEach((obs) => {
          ctx.fillStyle = "#555";

          switch (obs.type) {
            case "circle":
              const grad = ctx.createRadialGradient(obs.x, 480, obs.size * 0.2, obs.x, 480, obs.size / 2);
              grad.addColorStop(0, obs.color);
              grad.addColorStop(1, "#111"); // fade to dark
              ctx.fillStyle = grad;
              ctx.shadowColor = obs.color;
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.arc(obs.x, 480, obs.size / 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.shadowBlur = 0;
              break;

            case "triangle":
              const triangleGrad = ctx.createLinearGradient(obs.x, 500 - obs.size, obs.x, 500);
              triangleGrad.addColorStop(0, obs.color);
              triangleGrad.addColorStop(1, "#111");
              ctx.fillStyle = triangleGrad;
              ctx.shadowColor = obs.color;
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.moveTo(obs.x, 500 - obs.size);
              ctx.lineTo(obs.x - obs.size / 2, 500);
              ctx.lineTo(obs.x + obs.size / 2, 500);
              ctx.closePath();
              ctx.fill();
              ctx.shadowBlur = 0;
              break;

            case "square":
              const squareGrad = ctx.createLinearGradient(obs.x, 500 - obs.size, obs.x, 500);
              squareGrad.addColorStop(0, obs.color);
              squareGrad.addColorStop(1, "#111");
              ctx.fillStyle = squareGrad;
              ctx.shadowColor = obs.color;
              ctx.shadowBlur = 15;
              ctx.fillRect(obs.x - obs.size / 2, 500 - obs.size, obs.size, obs.size);
              ctx.shadowBlur = 0;
              break;

            case "tower":
              const towerGrad = ctx.createLinearGradient(obs.x, 500 - obs.height, obs.x, 500);
              towerGrad.addColorStop(0, obs.color);
              towerGrad.addColorStop(1, "#111");
              ctx.fillStyle = towerGrad;
              ctx.shadowColor = obs.color;
              ctx.shadowBlur = 15;
              ctx.fillRect(obs.x - obs.size / 2, 500 - obs.height, obs.size, obs.height);
              ctx.shadowBlur = 0;
              break;

            case "coin":
              ctx.save();
              ctx.translate(obs.x, obs.y); // merkeze ta≈üƒ±
              ctx.rotate((Date.now() / 1000) % (2 * Math.PI)); // yava≈ü√ßa d√∂nd√ºr

              const fixedSize = 80;
              ctx.drawImage(logo, -fixedSize / 2, -fixedSize / 2, fixedSize, fixedSize);

              ctx.restore();
              break;

            case "star":
              const starColors = ["yellow", "white", "gold", "#ffffcc"];
              const blinkColor = starColors[Math.floor(Date.now() / 150) % starColors.length];
              ctx.fillStyle = blinkColor;
              ctx.beginPath();
              ctx.moveTo(obs.x, obs.y);
              ctx.lineTo(obs.x + obs.size / 2, obs.y + obs.size);
              ctx.lineTo(obs.x - obs.size / 2, obs.y + obs.size / 3);
              ctx.lineTo(obs.x + obs.size / 2, obs.y + obs.size / 3);
              ctx.lineTo(obs.x - obs.size / 2, obs.y + obs.size);
              ctx.closePath();
              ctx.fill();
              break;

            case "dark_star":
              const darkStarColors = ["black", "silver", "gray", "#333"];
              const flicker = darkStarColors[Math.floor(Date.now() / 150) % darkStarColors.length];
              ctx.fillStyle = flicker;
              ctx.beginPath();
              ctx.moveTo(obs.x, obs.y);
              ctx.lineTo(obs.x + obs.size / 2, obs.y + obs.size);
              ctx.lineTo(obs.x - obs.size / 2, obs.y + obs.size / 3);
              ctx.lineTo(obs.x + obs.size / 2, obs.y + obs.size / 3);
              ctx.lineTo(obs.x - obs.size / 2, obs.y + obs.size);
              ctx.closePath();
              ctx.fill();
              break;

            case "shield":
              if (shieldLoaded) {
                const shieldSize = 100;
                ctx.drawImage(shieldImg, obs.x - shieldSize / 2, obs.y - shieldSize / 2, shieldSize, shieldSize);
              }
              break;
          }

          obs.x += gameSpeed;
        });

        for (let i = obstacles.length - 1; i >= 0; i--) {
          if (obstacles[i].x > canvas.width + 100) {
            obstacles.splice(i, 1);
          }
        }

        obstacleTimer--;
        if (obstacleTimer <= 0) {
          bonusTimer++;
          let type;

          if (bonusTimer >= 6) {
            bonusTimer = 0;
            const r = Math.random();
            if (r < 0.1) type = "dark_star";
            else if (r < 0.4) type = "shield";
            else if (r < 0.7) type = "coin";
            else type = "star";
          } else {
            const types = ["circle", "triangle", "square"];
            if (lastHoleObstacleCount >= 5) types.push("hole");
            type = types[Math.floor(Math.random() * types.length)];
          }

          const size =
            type === "hole"
              ? Math.min(80, 40 + Math.random() * 40)
              : type === "coin"
                ? Math.random() * 20 + 40
                : Math.random() * 20 + 30;

          let y = type === "hole" ? 0 : Math.random() * (500 - size * 1.5);

          // Delik sayacƒ±nƒ± g√ºncelle
          if (type === "hole") {
            lastHoleObstacleCount = 0;
            obstacles.push({
              type: "tower",
              x: -100 - 15 * gameSpeed,
              y: 500 - 160, // y√ºksekliƒüi 160 px
              size: 40,
              height: 160,
              color: neonColors[Math.floor(Math.random() * neonColors.length)] || "#000",
            });
          } else {
            lastHoleObstacleCount++;
          }

          const spawnCombo = !recentlySpawnedCombo && distance > 500 && Math.random() < 0.3;

          if (spawnCombo) {
            recentlySpawnedCombo = true;
            comboCooldownTimer = 300; // 5 saniye boyunca √ßiftli spawn olmasƒ±n (60 FPS * 5)
            const type2 = ["circle", "triangle", "square"].filter((t) => t !== type)[Math.floor(Math.random() * 2)];

            const size1 = size * 1.5;
            const size2 = size * 1.4;
            const spacing = 0;

            obstacles.push({
              type,
              x: -100,
              y,
              size: size * 1.5,
              color: neonColors[Math.floor(Math.random() * neonColors.length)] || "#000",
            });
            obstacleCount++;

            obstacles.push({
              type: type2,
              x: -100 - 60, // yanƒ±na biraz solda
              y,
              size: size * 1.4,
              color: neonColors[Math.floor(Math.random() * neonColors.length)] || "#000",
            });
            obstacleCount++;
          } else {
            obstacles.push({
              type,
              x: -100,
              y,
              size: size * 1.5,
              color: neonColors[Math.floor(Math.random() * neonColors.length)] || "#000",
            });
            obstacleCount++;
          }

          const spawnInterval = Math.max(30, 150 - difficultyLevel * 10);
          obstacleTimer = Math.random() * spawnInterval + spawnInterval;
        }
      }

      function getDiscoGlowColor() {
        const glowColors =
          darkBoostTimer > 0
            ? ["#111", "#333", "#555", "#999"]
            : ["#ff99cc", "#99ccff", "#ccff66", "#ffcc66", "#66ccff"];
        return glowColors[Math.floor(Date.now() / 150) % glowColors.length];
      }

      function drawSky() {
        let skyColor;

        const segments = [
          { t: 0.0, color: [174, 239, 255] }, // sabah
          { t: 0.15, color: [135, 206, 250] }, // g√ºnd√ºz
          { t: 0.45, color: [255, 145, 77] }, // g√ºnbatƒ±mƒ±
          { t: 0.6, color: [11, 11, 29] }, // gece
          { t: 0.85, color: [29, 81, 81] },
          { t: 1.0, color: [174, 239, 255] }, // yeniden sabah
        ];

        function interpolate(c1, c2, factor) {
          const r = Math.round(c1[0] + (c2[0] - c1[0]) * factor);
          const g = Math.round(c1[1] + (c2[1] - c1[1]) * factor);
          const b = Math.round(c1[2] + (c2[2] - c1[2]) * factor);
          return `rgb(${r}, ${g}, ${b})`;
        }

        for (let i = 0; i < segments.length - 1; i++) {
          const segStart = segments[i];
          const segEnd = segments[i + 1];

          if (timeOfDay >= segStart.t && timeOfDay < segEnd.t) {
            const localT = (timeOfDay - segStart.t) / (segEnd.t - segStart.t);
            skyColor = interpolate(segStart.color, segEnd.color, localT);
            break;
          }
        }

        ctx.fillStyle = skyColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        currentSkyColor = skyColor;
      }

      function drawSun() {
        if (!isDay) return;

        const sunX = canvas.width - timeOfDay * canvas.width * (1 / 0.6);
        const sunY = 100 - 40 * Math.sin((timeOfDay * Math.PI) / 0.6);
        const size = 30;

        ctx.beginPath();
        ctx.arc(sunX, sunY, size, 0, Math.PI * 2);
        ctx.fillStyle = "#FFD700";
        ctx.fill();
      }

      function drawMoon() {
        if (isDay) return;

        const t = (timeOfDay - 0.6) / 0.4;
        const moonX = t * canvas.width;
        const moonY = 100 - 40 * Math.sin(t * Math.PI);
        const size = 25;

        ctx.save();
        ctx.beginPath();
        ctx.arc(moonX, moonY, size, 0, Math.PI * 2);
        ctx.fillStyle = "#ccc";
        ctx.fill();
      }

      function drawClouds() {
        if (!isDay) return; // Gece bulut yok

        ctx.fillStyle = "#fff";
        clouds.forEach((cloud) => {
          ctx.beginPath();
          ctx.arc(cloud.x, cloud.y, 20, 0, Math.PI * 2);
          ctx.arc(cloud.x + 20, cloud.y + 10, 25, 0, Math.PI * 2);
          ctx.arc(cloud.x - 20, cloud.y + 10, 20, 0, Math.PI * 2);
          ctx.fill();
          cloud.x -= 0.5;
          if (cloud.x < -50) cloud.x = canvas.width + 50;
        });
      }

      function drawBirds() {
        if (!isDay) return; // Gece ku≈ülar uyuyor üí§

        ctx.strokeStyle = "#000";
        birds.forEach((bird) => {
          ctx.beginPath();
          ctx.moveTo(bird.x, bird.y);
          ctx.lineTo(bird.x + 5, bird.y - 5);
          ctx.lineTo(bird.x + 10, bird.y);
          ctx.stroke();
          bird.x -= 1;
          if (bird.x < -20) bird.x = canvas.width + 20;
        });
      }

      function drawScore() {
        ctx.fillStyle = "#000";
        ctx.font = "30px Arial";
        ctx.textAlign = "left";
        ctx.fillText(`Lives: ${lives}`, 10, canvas.height - 20);

        ctx.textAlign = "right";
        ctx.fillText(`Distance: ${distance.toFixed(1)} m`, canvas.width - 10, canvas.height - 20);
      }

      function drawBonusMessage(delta) {
        if (bonusMessageTimer > 0) {
          ctx.font = "32px Arial";
          ctx.fillStyle = "#000";
          ctx.textAlign = "center";
          ctx.fillText(bonusMessage, canvas.width / 2, canvas.height / 2);
          bonusMessageTimer -= delta * 60;
        }
      }

      function drawStatusMessage() {
        const isBoostActive = speedBoostTimer > 0 || darkBoostTimer > 0 || shieldTimer > 0;
        if (isBoostActive && statusMessage) {
          ctx.save();
          ctx.font = "20px Arial";
          ctx.textAlign = "left";
          ctx.fillStyle = Math.floor(Date.now() / 150) % 2 === 0 ? "#f00" : "#000";

          let countdown = "";
          if (shieldTimer > 0) countdown = `${Math.ceil(shieldTimer / 60)}s`;
          else if (darkBoostTimer > 0) countdown = `${Math.ceil(darkBoostTimer / 60)}s`;
          else if (speedBoostTimer > 0) countdown = `${Math.ceil(speedBoostTimer / 60)}s`;

          ctx.fillText(statusMessage + countdown, 10, canvas.height - 60);
          ctx.restore();
        }
      }

      function handleJump() {
        if (player.isJumping) {
          player.y += player.velocityY;
          player.velocityY += gravity;

          if (player.y >= 480) {
            player.y = 480;
            player.velocityY = 0;
            player.isJumping = false;
            jumpCount = 0;
            lastJumpCount = 0;
          }
        }
      }

      function checkCollision() {
        if (isGameOver || rebirthTimer > 0) return;

        const playerBottom = player.y + player.legLength + player.footSize;

        for (let obs of obstacles) {
          if (["coin", "star", "dark_star", "shield"].includes(obs.type)) continue;
          if (obs.x + obs.size < 0 || obs.x - obs.size > canvas.width) continue;

          if (obs.type === "hole") {
            const isOverHole = player.x > obs.x && player.x < obs.x + obs.size;
            if (isOverHole && !player.isJumping && !player.fallingInHole && !darkStarInvincible) {
              player.fallingInHole = true;
              holeFallData = {
                velocity: 2,
                angle: 0,
                rotationSpeed: 0.2,
              };
              playSound("hole");
              break;
            }
          } else {
            const obstacleHeight = obs.type === "tower" ? obs.height : obs.size;
            const obstacleTop = 500 - obstacleHeight;
            const obstacleLeft = obs.x - obs.size / 2;
            const obstacleRight = obs.x + obs.size / 2;

            const hits = playerBottom > obstacleTop && player.x > obstacleLeft && player.x < obstacleRight;

            if (hits) {
              if (darkStarInvincible) continue;

              if (shieldTimer > 0) {
                statusMessage = "Shield Active!";
                statusTimer = 60;
              } else {
                loseLife();
              }
              break;
            }
          }
        }
      }

      function loseLife() {
        if (isGameOver) return;
        if (damageCooldown > 0 || rebirthTimer > 0) return;

        playSound("hit");
        lives--;
        damageCooldown = 80;
        rebirthTimer = 80;
        isBlinking = true;

        if (lives <= 0) {
          isGameOver = true;
          sounds.bgm.pause();
          sounds.bgm.currentTime = 0;
          playSound("gameover");
          window.FarcadeSDK?.singlePlayer?.actions?.gameOver?.({
            score: Math.floor(distance),
          });

          cancelAnimationFrame(loopId);
        }
      }

      function clearAllBonuses() {
        speedBoostTimer = 0;
        darkBoostTimer = 0;
        shieldTimer = 0;
        hasShield = false;
        darkStarInvincible = false;
      }

      function isNearBonus(obs) {
        const bonusWidth = obs.size * 0.9;
        const bonusHeight = obs.size * 0.9;

        const playerTop = player.y - player.torsoLength - 80; // kafa dahil yukarƒ±
        const playerBottom = player.y + player.legLength + player.footSize;

        return (
          player.x > obs.x - bonusWidth / 2 &&
          player.x < obs.x + bonusWidth / 2 &&
          playerBottom > obs.y &&
          playerTop < obs.y + bonusHeight
        );
      }

      function handleBonuses(delta = 1 / 60) {
        obstacles.forEach((obs, index) => {
          const isCoin = obs.type === "coin" && isNearBonus(obs);
          const isStar = obs.type === "star" && isNearBonus(obs);
          const isDarkStar = obs.type === "dark_star" && isNearBonus(obs);
          const isShield = obs.type === "shield" && isNearBonus(obs);

          if (isCoin) {
            playSound("coin");
            lives++;
            bonusMessage = "Extra life!";
            bonusMessageTimer = 60;
            obstacles.splice(index, 1);
            distance += 250;
          }

          if (isStar) {
            clearAllBonuses();
            playSound("star");
            speedBoostTimer = 900;
            bonusMessage = "Star collected!";
            bonusMessageTimer = 60;
            statusMessage = "Speed Reset!";
            statusTimer = 100;
            obstacles.splice(index, 1);
            distance += 100;
          }

          if (isDarkStar) {
            clearAllBonuses();
            playSound("darkstar");
            darkBoostTimer = 600;
            darkBoostedSpeed = baseSpeed + Math.floor(obstacleCount / 5) * 0.6;
            darkStarInvincible = true;
            bonusMessage = "Dark Mode Activated!";
            bonusMessageTimer = 60;
            statusMessage = "Speed Boost! + Invincible!";
            statusTimer = 100;
            obstacles.splice(index, 1);
            distance += 1000;
          }

          if (isShield) {
            clearAllBonuses();
            playSound("shield");
            shieldTimer = 1200;
            hasShield = true;
            bonusMessage = "Shield On!";
            bonusMessageTimer = 60;
            statusMessage = "Protected!";
            statusTimer = 100;
            obstacles.splice(index, 1);
            distance += 250;
          }
        });

        // üéØ BONUS ETKƒ∞LERƒ∞ zaman bazlƒ± azaltma
        if (darkBoostTimer > 0) {
          gameSpeed = darkBoostedSpeed * 2;
          darkBoostTimer -= delta * 60;
          if (darkBoostTimer <= 0) {
            darkStarInvincible = false;
            darkBoostTimer = 0;
          }
        } else if (speedBoostTimer > 0) {
          gameSpeed = baseSpeed;
          speedBoostTimer -= delta * 60;
          if (speedBoostTimer <= 0) speedBoostTimer = 0;
        } else {
          gameSpeed = baseSpeed + Math.floor(obstacleCount / 5) * 0.2;
        }

        if (shieldTimer > 0) {
          shieldTimer -= delta * 60;
          if (shieldTimer <= 0) {
            shieldTimer = 0;
            hasShield = false;
          }
        }
      }

      function setStatus(stat, msg) {
        statusMessage = stat;
        statusTimer = 100;
        bonusMessage = msg;
        bonusMessageTimer = 60;
      }

      function showBonus(msg) {
        bonusMessage = msg;
        bonusMessageTimer = 60;
      }

      function updateBonusEffects(delta) {
        if (darkBoostTimer > 0) {
          gameSpeed = darkBoostedSpeed * 2;
          darkBoostTimer -= delta * 60;
          if (darkBoostTimer <= 0) darkStarInvincible = false;
        } else if (speedBoostTimer > 0) {
          gameSpeed = baseSpeed;
          speedBoostTimer -= delta * 60;
        } else {
          gameSpeed = baseSpeed + Math.floor(obstacleCount / 5) * 0.6;
        }

        if (shieldTimer > 0) {
          shieldTimer -= delta * 60;
          if (shieldTimer <= 0) hasShield = false;
        }
      }

      // Hints label tƒ±klanƒ±nca guide screen a√ß
      document.getElementById("hint-label").addEventListener("click", () => {
        document.getElementById("guide-screen").style.display = "block";
        document.getElementById("start-screen").style.display = "none";
      });

      // Guide screen'deki "Back" tu≈üuna tƒ±klanƒ±nca start screen geri gelsin
      document.getElementById("close-guide").addEventListener("click", () => {
        document.getElementById("guide-screen").style.display = "none";
        document.getElementById("start-screen").style.display = "block";
      });

      // Start the Run tƒ±klanƒ±nca oyunu ba≈ülat
      document.getElementById("start-run-label").addEventListener("click", () => {
        document.getElementById("start-screen").style.display = "none";
        window.FarcadeSDK?.singlePlayer?.actions?.ready?.();
        sounds.bgm.currentTime = 0;
        sounds.bgm.play();
        lastTime = performance.now();
        if (loopId) cancelAnimationFrame(loopId);
        loopId = requestAnimationFrame(loop);
      });

      // Play again sinyali gelirse oyunu resetle
      window.FarcadeSDK?.on?.("play_again", () => {
        resetGame();
        document.getElementById("start-screen").style.display = "none";
        lastTime = performance.now();
        loopId = requestAnimationFrame(loop);
      });

      window.FarcadeSDK?.on?.("toggle_mute", (data) => {
        isMuted = data?.isMuted;
        Object.values(sounds).forEach((sound) => (sound.muted = isMuted));
        console.log("Muted:", isMuted);
      });

      function resetGame() {
        lives = 1;
        distance = 0.1;
        isGameOver = false;
        player.y = 480;
        jumpCount = 0;
        lastJumpCount = 0;
        obstacleCount = 0;
        gameSpeed = baseSpeed;
        obstacles.length = 0;

        ghostOpacity = 1;
        rebirthTimer = 0;

        shieldTimer = 0;
        hasShield = false;

        bonusTimer = 0;
        difficultyLevel = 1;
        obstacleDifficultyTimer = 0;

        sounds.bgm.currentTime = 0;
        sounds.bgm.play();

        timeOfDay = 0;
        isDay = true;

        speedBoostTimer = 0;
        darkBoostTimer = 0;
        statusMessage = "";

        darkBoostedSpeed = 8;

        holeFallData = null;
        player.fallingInHole = false;
        showTribune = false;
        currentTribune = 1;
        nextTribuneDistance = 5;
        tribuneTimer = 0;
        tribuneX = 0;
        tribune2X = 0;
        roadType = 1;
        nextRoadSwitch = 250;
        let roadScrollX = 0;
        roadScrollX += 1.5;
      }

      function loop(currentTime) {
        const delta = (currentTime - lastTime) / 1000; // saniye
        lastTime = currentTime;

        if (isGameOver) return;
        obstacleTimer -= delta * 60;
        comboCooldownTimer -= delta * 60;
        rebirthTimer -= delta * 60;
        damageCooldown -= delta * 60;
        statusTimer -= delta * 60;

        if (comboCooldownTimer < 0) comboCooldownTimer = 0;
        if (rebirthTimer < 0) rebirthTimer = 0;
        if (damageCooldown < 0) damageCooldown = 0;
        if (statusTimer < 0) statusTimer = 0;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawSky();
        drawSun();
        drawMoon();
        drawClouds();
        drawBirds();
        drawTribunes(delta);
        drawRoad();
        if (!showTribune && distance >= nextTribuneDistance) {
          showTribune = true;
          tribuneTimer = 600;
          currentTribune = (currentTribune % tribunes.length) + 1;
          nextTribuneDistance = distance + (currentTribune === 1 ? 100 : 50);

          // ‚úÖ Yol deƒüi≈üimini tribune ile senkron yap
          roadType = 1 + Math.floor(Math.random() * 3);

          sounds.crowd.currentTime = 0;
          sounds.crowd.play();
        }

        handleJump();
        if (isBackflipping) {
          backflipAngle += 20;
          if (backflipAngle >= 360) {
            backflipAngle = 0;
            isBackflipping = false;
          }
        }

        if (player.fallingInHole && holeFallData) {
          player.y += holeFallData.velocity;
          holeFallData.velocity += 0.5;
          holeFallData.angle += holeFallData.rotationSpeed;

          ctx.save();
          ctx.translate(player.x, player.y);
          ctx.rotate(holeFallData.angle);
          ctx.restore();

          if (player.y > canvas.height + 100) {
            loseLife();
            player.fallingInHole = false;
            player.y = 480;
            holeFallData = null;
          }
        }

        drawBonusMessage(delta); // ‚úÖ delta parametresi eklendi
        timeOfDay += 1 / (60 * 100);
        if (timeOfDay >= 1) timeOfDay = 0;
        isDay = timeOfDay < 0.6;

        drawCharacter();
        drawObstacles();
        drawScore();
        drawStatusMessage();

        checkCollision();
        handleBonuses(delta);

        distance += delta * gameSpeed * 2;
        obstacleDifficultyTimer += delta;
        if (obstacleDifficultyTimer >= 10) {
          difficultyLevel++;
          gameSpeed = baseSpeed + difficultyLevel * 0.5;
          obstacleDifficultyTimer = 0;
        }

        angle += 0.1;

        if (rebirthTimer > 0) {
          ghostOpacity = (Math.sin(rebirthTimer / 5) + 1) / 2;
        } else {
          ghostOpacity = 1;
          isBlinking = false;
        }

        if (comboCooldownTimer > 0 && --comboCooldownTimer === 0) {
          recentlySpawnedCombo = false;
        }

        if (shieldTimer > 0) shieldTimer--;

        // ‚úÖ Ana d√ºzeltme ‚Äî sadece bu satƒ±r
        loopId = requestAnimationFrame(loop);
      }

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && jumpCount < maxJump) {
          player.isJumping = true;
          player.velocityY = jumpVelocity;
          jumpCount++;
          playSound("jump");
        }

        if (jumpCount === 2 && lastJumpCount < 2) {
          isBackflipping = true;
          backflipAngle = 0;
        }

        lastJumpCount = jumpCount;
      });

      document.getElementById("start-run-label").addEventListener("click", () => {
        document.getElementById("start-screen").style.display = "none";
        window.FarcadeSDK?.singlePlayer?.actions?.ready?.();
        sounds.bgm.currentTime = 0;
        sounds.bgm.play();
        lastTime = performance.now();
        if (loopId) cancelAnimationFrame(loopId);
        loopId = requestAnimationFrame(loop);
      });

      const doubleJumpWindow = 1000;
      let lastJumpTime = 0;

      function handleJumpLogic() {
        const now = Date.now();
        if (jumpCount < maxJump) {
          player.isJumping = true;
          player.velocityY = jumpVelocity;
          jumpCount++;
          playSound("jump");
        }

        if (jumpCount === 2 && lastJumpCount < 2) {
          isBackflipping = true;
          backflipAngle = 0;

          lastJumpTime = now;
          lastJumpCount = jumpCount;
        }
      }

      let lastTouchTime = 0;
      let touchStartTime = 0;
      const tapThreshold = 400;
      const clickDelay = 500;

      document.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
        },
        { passive: false },
      );

      canvas.addEventListener("touchstart", () => {
        touchStartTime = Date.now();
      });

      canvas.addEventListener("touchend", () => {
        const now = Date.now();
        if (now - touchStartTime <= tapThreshold) {
          lastTouchTime = now;
          handleJumpLogic();
        }
      });

      canvas.addEventListener("click", () => {
        if (Date.now() - lastTouchTime < 1000) return; // √áift zƒ±plama olmasƒ±n
        handleJumpLogic();
      });
    </script>
  </body>
</html>
